#include "hal_data.h"

#define TEXT_LENGTH                 (256)

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event)
BSP_PLACE_IN_SECTION(".warm_start");
FSP_CPP_FOOTER

void g_timer0CB(timer_callback_args_t *p_args);
void user_uart_callback (uart_callback_args_t * p_args);


uint8_t g_receive_buffer[TEXT_LENGTH] = {0};
volatile uint32_t g_transfer_complete = 0;
volatile uint32_t g_receive_complete  = 0;

volatile uint32_t gpt0Cnt = 0;//for test
volatile uint32_t recvCnt = 0;//for test

/*******************************************************************************************************************//**
 * main() is generated by the FSP Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */
    fsp_err_t err = g_uart0.p_api->open(g_uart0.p_ctrl, g_uart0.p_cfg);
    FSP_PARAMETER_NOT_USED(err);

    __asm volatile ("cpsie i");

    g_uart0.p_api->write(g_uart0.p_ctrl, (uint8_t *)"hello world!\n", sizeof("hello world!\n"));

    g_timer0.p_api->open(g_timer0.p_ctrl, g_timer0.p_cfg);
    g_timer0.p_api->enable(g_timer0.p_ctrl);

    g_elc.p_api->open(g_elc.p_ctrl, g_elc.p_cfg);
    g_elc.p_api->enable(g_elc.p_ctrl);

    g_timer0_ctrl.p_reg->GTSSR = GPT_SOURCE_GPT_A;//SCI RX p16-6--->ELC single port0--->LLPP GPT event A(GPT_SOURCE_GPT_A)--->GTSSR(Start Source)
    g_timer0_ctrl.p_reg->GTCSR = GPT_SOURCE_GPT_B;//SCI RX p16-6--->ELC single port0--->LLPP GPT event B(GPT_SOURCE_GPT_B)--->GTCSR(clear Source)

    R_SCI_UART_Read(&g_uart0_ctrl, (uint8_t*)g_receive_buffer, TEXT_LENGTH);//start uart0 dma rx

    while(1)
    {
        R_BSP_SoftwareDelay (1000, BSP_DELAY_UNITS_MILLISECONDS);
    }
}

void g_timer0CB(timer_callback_args_t *p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);

    transfer_properties_t p_info;
    R_DMAC_InfoGet (g_transfer1.p_ctrl, &p_info);//rx dma

    uint8_t len = (uint8_t)(TEXT_LENGTH - p_info.transfer_length_remaining);//buf max - remaining = current recv len

    if(len > 0)
    {
        R_SCI_UART_Write(&g_uart0_ctrl, (uint8_t *)g_receive_buffer, TEXT_LENGTH - p_info.transfer_length_remaining);//for test

        R_SCI_UART_Read(&g_uart0_ctrl, (uint8_t*)g_receive_buffer, TEXT_LENGTH);//start uart0 dma rx
    }

    gpt0Cnt++;//for test
}

void user_uart_callback (uart_callback_args_t * p_args)
{
    /* Handle the UART event */
    switch (p_args->event)
    {
        /* Received a character */
        case UART_EVENT_RX_CHAR:
        {
            break;
        }
        /* Receive complete */
        case UART_EVENT_RX_COMPLETE:
        {
            transfer_properties_t p_info;
            R_DMAC_InfoGet (g_transfer0.p_ctrl, &p_info);

            R_SCI_UART_Write(&g_uart0_ctrl, (uint8_t *)g_receive_buffer, TEXT_LENGTH - p_info.transfer_length_remaining);//for test

            R_SCI_UART_Read(&g_uart0_ctrl, (uint8_t*)g_receive_buffer, TEXT_LENGTH);//start uart0 dma rx

            recvCnt++;//for test

            g_receive_complete = 1;
            break;
        }
        /* Transmit complete */
        case UART_EVENT_TX_COMPLETE:
        {
            g_transfer_complete = 1;
            break;
        }
        default:
        {
        }
    }
}


/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
        /* Pre clock initialization */
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, &g_bsp_pin_cfg);
    }
}
