#include "hal_data.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event)
BSP_PLACE_IN_SECTION(".warm_start");
FSP_CPP_FOOTER

uint8_t sendBuf[128] BSP_PLACE_IN_SECTION(".data_noncache.sendBuf");
uint8_t recvBuf[128] BSP_PLACE_IN_SECTION(".data_noncache.recvBuf");

#ifndef PRINTF
#define PRINTF
#endif
#ifdef PRINTF
#include <stdio.h>
/**
 * notice: g_uart0CB; g_uart0_ctrl
 */
volatile bool uart_send_complete_flag = false;
void user_uart_callback (uart_callback_args_t * p_args)
{
    if(p_args->event == UART_EVENT_TX_COMPLETE)
    {
        uart_send_complete_flag = true;
    }
}

int _write(int fd, char *pBuffer, int size);
int _write(int fd, char *pBuffer, int size)
{
   (void)fd;
   fsp_err_t err = R_SCI_UART_Write(&g_uart0_ctrl, (uint8_t *)pBuffer, (uint32_t)size);
   if(FSP_SUCCESS != err) __BKPT();
   while(uart_send_complete_flag == false);
   uart_send_complete_flag = false;

   return size;
}

#endif//PRINTF



/*******************************************************************************************************************//**
 * main() is generated by the FSP Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */
#ifdef PRINTF
    g_uart0.p_api->open(&g_uart0_ctrl, &g_uart0_cfg);
    __asm volatile ("cpsie i");
    g_uart0.p_api->write(&g_uart0_ctrl, (uint8_t *)"hello word!\n", strlen("hello word!\n"));
    while(!uart_send_complete_flag);
    uart_send_complete_flag = false;
    printf("date:%s\ntime:%s\nfile:%s\nfunc:%s,line:%d\nhello world!\n", __DATE__, __TIME__, __FILE__, __FUNCTION__, __LINE__);

    float PI = 3.1415926f;
    printf("PI=%f\n", PI);
#endif//PRINTF

    g_timer0.p_api->open(g_timer0.p_ctrl, g_timer0.p_cfg);
    g_timer0.p_api->start(g_timer0.p_ctrl);
    g_timer0.p_api->enable(g_timer0.p_ctrl);

    extern void coremain(void);
    printf("check script ld first!!!\r\n");
    printf("start coremain!!!\r\n");
    coremain();

    //func_atcm_bss_init();
    uint32_t freq_hz = R_FSP_SystemClockHzGet(FSP_PRIV_CLOCK_CPU0);
    printf("FSP_PRIV_CLOCK_CPU0=%ld\r\n", freq_hz);

    while (1)
    {
        printf("running!!!\r\n");
        //R_BSP_SoftwareDelay(1000, BSP_DELAY_UNITS_MILLISECONDS);
        bsp_prv_software_delay_loop(100000000);

        static uint32_t cnt = 0;
        sendBuf[0] = cnt++;
    }
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
        /* Pre clock initialization */
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, &g_bsp_pin_cfg);
    }
}

 volatile unsigned int coremarkTick;
void g_timer0CB(timer_callback_args_t *p_args)
{
    if (TIMER_EVENT_CYCLE_END == p_args->event)
    {
        coremarkTick++;
    }
}
